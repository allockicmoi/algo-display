{"version":3,"sources":["logo.svg","Square.jsx","search_algos/BFS.js","search_algos/DFS.js","search_algos/Astar.js","SelectionBar.jsx","maze_algos/backtracker.js","maze_algos/kruskal.js","maze_algos/prims.js","maze_algos/wilson.js","Grid.jsx","Display.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","CenterGrid","props","this","mouseDown","isStart","isEnd","toggleWall","row","col","startSelected","moveStart","endSelected","moveEnd","selectStart","selectEnd","toggleWallOnce","isWall","extraClass","id","className","onMouseEnter","handleMouseEnter","onMouseDownCapture","handleMouseDown","Component","BFS","grid","start","end","console","log","ind","visited","toVisit","vstd","shortestPath","i","currentNode","neighbs","GetUnvisitedNeighbours","child","includes","parent","push","shift","path","current","reverse","BacktrackShortest","node","neighbours","Astar","_grid","slice","heuristic","source","dest","Math","sqrt","pow","generateHeuristic","sort","compareEuclidean","square1","square2","SelectionBar","state","algo","options","onChange","updateAlgo","value","algoName","onClick","clear","updateMazeAlgo","mazeAlgoName","mazeAlgo","BackTrack","stack","length","nextNode","GetPossibleNode","pop","walls","nodeList","n","floor","random","Kruskal","sets","max_iter","set","Set","add","InitializeGrid","index","wall","ValidHorizontalWall","set1","findContainingSet","set2","splice","elem","ValidVerticalWall","has","Prims","isFresh","bind","refreshAndAnimate","refreshAndAnimateMaze","setState","tempGrid","found","DFS","Wilson","orderedSquares","setTimeout","pathIndex","square","document","getElementById","resetWalls","RefreshGrid","newStart","newEnd","animateSearchAlgo","animateMazeAlgo","createWalls","forceUpdate","onMouseDown","onMouseUp","mouseUp","map","rIndex","key","cIndex","tempRow","gridOrig","Display","icon","faCubes","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.0a0c3fd5.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { Component } from \"react\";\r\nimport \"./Square.css\";\r\n\r\nexport default class CenterGrid extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n  }\r\n  // componentDidUpdate() {\r\n  //   this.setState({ isWall: this.props.isWall });\r\n  // }\r\n  toggleWall() {\r\n    if (this.props.mouseDown && !this.props.isStart && !this.props.isEnd) {\r\n      this.props.toggleWall(this.props.row, this.props.col);\r\n    }\r\n  }\r\n  toggleWallOnce() {\r\n    if (!this.props.isStart && !this.props.isEnd) {\r\n      this.props.toggleWall(this.props.row, this.props.col);\r\n    }\r\n  }\r\n  handleMouseEnter() {\r\n    if (this.props.startSelected) {\r\n      this.props.moveStart(this.props.row, this.props.col);\r\n    } else if (this.props.endSelected) {\r\n      this.props.moveEnd(this.props.row, this.props.col);\r\n    } else {\r\n      this.toggleWall();\r\n    }\r\n  }\r\n  handleMouseDown() {\r\n    if (this.props.isStart) {\r\n      this.props.selectStart();\r\n    } else if (this.props.isEnd) {\r\n      this.props.selectEnd();\r\n    } else {\r\n      this.toggleWallOnce();\r\n    }\r\n  }\r\n  render() {\r\n    const { row, col, isStart, isEnd, isWall } = this.props;\r\n    // console.log(this.props.row);\r\n    const extraClass = isStart ? \"start\" : isEnd ? \"end\" : isWall ? \"wall\" : \"\";\r\n    return (\r\n      <div\r\n        id={`square-${row}-${col}`}\r\n        className={`square  ${extraClass}`}\r\n        onMouseEnter={() => this.handleMouseEnter()}\r\n        onMouseDownCapture={() => this.handleMouseDown()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","export function BFS(grid, start, end) {\r\n  // console.log(start);\r\n  console.log(start);\r\n  for (const row in grid) {\r\n    for (const ind in grid[row]) {\r\n      grid[row][ind].visited = false;\r\n    }\r\n  }\r\n  const toVisit = [];\r\n  const vstd = [];\r\n  const shortestPath = [];\r\n  let i = 0;\r\n  let currentNode = start;\r\n  while (currentNode !== end) {\r\n    let neighbs = GetUnvisitedNeighbours(currentNode, grid);\r\n    // console.log(neighbs);\r\n\r\n    for (let child in neighbs) {\r\n      // console.log(neighbs[child]);\r\n\r\n      if (!toVisit.includes(neighbs[child])) {\r\n        neighbs[child].parent = currentNode;\r\n        toVisit.push(neighbs[child]);\r\n      }\r\n    }\r\n    //console.log(toVisit);\r\n    currentNode.visited = true;\r\n    grid[currentNode.row][currentNode.col].visited = true;\r\n    vstd.push(currentNode);\r\n    currentNode = toVisit.shift();\r\n    i++;\r\n    if (i > 1000) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  BacktrackShortest(shortestPath, end, start);\r\n\r\n  //console.log(shortestPath);\r\n  return { vstd, shortestPath };\r\n}\r\nfunction BacktrackShortest(path, end, start) {\r\n  let current = end;\r\n  let i = 0;\r\n  while (current !== start && i < 500) {\r\n    //console.log(current);\r\n\r\n    path.push(current);\r\n    current = current.parent;\r\n    i++;\r\n  }\r\n  path.push(start);\r\n  path = path.reverse();\r\n  return path;\r\n}\r\nfunction GetUnvisitedNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  // console.log(node);\r\n  const row = node.row;\r\n  const col = node.col;\r\n  if (row !== 0) {\r\n    if (\r\n      grid[row - 1][col].visited === false &&\r\n      grid[row - 1][col].isWall === false\r\n    ) {\r\n      neighbours.push(grid[row - 1][col]);\r\n    }\r\n    //console.log(grid[row - 1][col].visited === false);\r\n  }\r\n\r\n  if (row !== 20) {\r\n    if (\r\n      grid[row + 1][col].visited === false &&\r\n      grid[row + 1][col].isWall === false\r\n    ) {\r\n      //console.log(\"adding neighbours\");\r\n      neighbours.push(grid[row + 1][col]);\r\n    }\r\n  }\r\n  if (col !== 0) {\r\n    if (\r\n      grid[row][col - 1].visited === false &&\r\n      grid[row][col - 1].isWall === false\r\n    ) {\r\n      neighbours.push(grid[row][col - 1]);\r\n    }\r\n  }\r\n  if (col !== 40) {\r\n    if (\r\n      grid[row][col + 1].visited === false &&\r\n      grid[row][col + 1].isWall === false\r\n    ) {\r\n      neighbours.push(grid[row][col + 1]);\r\n    }\r\n  }\r\n  return neighbours;\r\n}\r\n","export function DFS(grid, start, end) {\r\n  //   console.log(start);\r\n  //   console.log(end);\r\n  for (const row in grid) {\r\n    for (const ind in grid[row]) {\r\n      grid[row][ind].visited = false;\r\n    }\r\n  }\r\n  const toVisit = [];\r\n  const vstd = [];\r\n  const shortestPath = [];\r\n  let i = 0;\r\n  let currentNode = start;\r\n  let found = false;\r\n  while (currentNode !== end) {\r\n    let neighbs = GetUnvisitedNeighbours(currentNode, grid);\r\n    console.log(neighbs);\r\n\r\n    for (let child in neighbs) {\r\n      // console.log(neighbs[child]);\r\n      if (neighbs[child] === end) {\r\n        found = true;\r\n      } else if (!neighbs[child].visited) {\r\n        if (!toVisit.includes(neighbs[child])) {\r\n          neighbs[child].parent = currentNode;\r\n        }\r\n\r\n        toVisit.push(neighbs[child]);\r\n      }\r\n    }\r\n\r\n    //console.log(toVisit);\r\n    if (found) {\r\n      end.parent = currentNode;\r\n      vstd.push(currentNode);\r\n      break;\r\n    } else {\r\n      currentNode.visited = true;\r\n      grid[currentNode.row][currentNode.col].visited = true;\r\n      vstd.push(currentNode);\r\n      currentNode = toVisit.pop();\r\n      i++;\r\n    }\r\n\r\n    if (i > 1000) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  BacktrackShortest(shortestPath, end, start);\r\n\r\n  //console.log(shortestPath);\r\n  return { vstd, shortestPath };\r\n}\r\nfunction BacktrackShortest(path, end, start) {\r\n  let current = end;\r\n  let i = 0;\r\n  while (current !== start && i < 500) {\r\n    //console.log(current);\r\n\r\n    path.push(current);\r\n    current = current.parent;\r\n    i++;\r\n  }\r\n  path.push(start);\r\n  path = path.reverse();\r\n  return path;\r\n}\r\nfunction GetUnvisitedNeighbours(node, grid) {\r\n  // console.log(node);\r\n  const neighbs = [];\r\n  const row = node.row;\r\n  const col = node.col;\r\n  if (row !== 0) {\r\n    if (\r\n      grid[row - 1][col].visited === false &&\r\n      grid[row - 1][col].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row - 1][col]);\r\n    }\r\n    //console.log(grid[row - 1][col].visited === false);\r\n  }\r\n  if (col !== 0) {\r\n    if (\r\n      grid[row][col - 1].visited === false &&\r\n      grid[row][col - 1].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row][col - 1]);\r\n    }\r\n  }\r\n  if (col !== 40) {\r\n    if (\r\n      grid[row][col + 1].visited === false &&\r\n      grid[row][col + 1].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row][col + 1]);\r\n    }\r\n  }\r\n\r\n  if (row !== 20) {\r\n    if (\r\n      grid[row + 1][col].visited === false &&\r\n      grid[row + 1][col].isWall === false\r\n    ) {\r\n      //console.log(\"adding neighbours\");\r\n      neighbs.push(grid[row + 1][col]);\r\n    }\r\n  }\r\n\r\n  return neighbs;\r\n}\r\n","export function Astar(_grid, start, end) {\r\n  // console.log(start);\r\n  const grid = _grid.slice();\r\n  generateHeuristic(grid, end);\r\n  console.log(grid);\r\n  for (const row in grid) {\r\n    for (const ind in grid[row]) {\r\n      grid[row][ind].visited = false;\r\n    }\r\n  }\r\n  const toVisit = [];\r\n  const vstd = [];\r\n  const shortestPath = [];\r\n  let i = 0;\r\n  let currentNode = start;\r\n  while (currentNode !== end) {\r\n    let neighbs = GetUnvisitedNeighbours(currentNode, grid);\r\n    // console.log(neighbs);\r\n\r\n    for (let child in neighbs) {\r\n      // console.log(neighbs[child]);\r\n\r\n      if (!toVisit.includes(neighbs[child])) {\r\n        neighbs[child].parent = currentNode;\r\n        toVisit.push(neighbs[child]);\r\n      }\r\n    }\r\n    //console.log(toVisit);\r\n    currentNode.visited = true;\r\n    grid[currentNode.row][currentNode.col].visited = true;\r\n    vstd.push(currentNode);\r\n    toVisit.sort(compareEuclidean);\r\n    currentNode = toVisit.shift();\r\n    i++;\r\n    if (i > 1000) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  BacktrackShortest(shortestPath, end, start);\r\n\r\n  //console.log(shortestPath);\r\n  return { vstd, shortestPath };\r\n}\r\nfunction BacktrackShortest(path, end, start) {\r\n  let current = end;\r\n  let i = 0;\r\n  while (current !== start && i < 500) {\r\n    //console.log(current);\r\n\r\n    path.push(current);\r\n    current = current.parent;\r\n    i++;\r\n  }\r\n  path.push(start);\r\n  path = path.reverse();\r\n  return path;\r\n}\r\nfunction generateHeuristic(grid, end) {\r\n  for (const row in grid) {\r\n    for (const col in grid[row]) {\r\n      grid[row][col].heuristic = EuclideanDistance(grid[row][col], end);\r\n    }\r\n  }\r\n}\r\nfunction EuclideanDistance(source, dest) {\r\n  return Math.sqrt(\r\n    Math.pow(dest.row - source.row, 2) + Math.pow(dest.col - source.col, 2)\r\n  );\r\n}\r\nfunction compareEuclidean(square1, square2) {\r\n  if (square1.heuristic > square2.heuristic) return 1;\r\n  if (square1.heuristic < square2.heuristic) return -1;\r\n\r\n  return 0;\r\n}\r\nfunction GetUnvisitedNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  // console.log(node);\r\n  const row = node.row;\r\n  const col = node.col;\r\n  if (row !== 0) {\r\n    if (\r\n      grid[row - 1][col].visited === false &&\r\n      grid[row - 1][col].isWall === false\r\n    ) {\r\n      neighbours.push(grid[row - 1][col]);\r\n    }\r\n    //console.log(grid[row - 1][col].visited === false);\r\n  }\r\n\r\n  if (row !== 20) {\r\n    if (\r\n      grid[row + 1][col].visited === false &&\r\n      grid[row + 1][col].isWall === false\r\n    ) {\r\n      //console.log(\"adding neighbours\");\r\n      neighbours.push(grid[row + 1][col]);\r\n    }\r\n  }\r\n  if (col !== 0) {\r\n    if (\r\n      grid[row][col - 1].visited === false &&\r\n      grid[row][col - 1].isWall === false\r\n    ) {\r\n      neighbours.push(grid[row][col - 1]);\r\n    }\r\n  }\r\n  if (col !== 40) {\r\n    if (\r\n      grid[row][col + 1].visited === false &&\r\n      grid[row][col + 1].isWall === false\r\n    ) {\r\n      neighbours.push(grid[row][col + 1]);\r\n    }\r\n  }\r\n  return neighbours;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./Grid.css\";\r\nimport Dropdown from \"react-dropdown\";\r\nimport \"react-dropdown/style.css\";\r\nimport \"./SelectionBar.css\";\r\nexport default class SelectionBar extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { algo: \"BFS\" };\r\n  }\r\n\r\n  render() {\r\n    const algos = [\"BFS\", \"DFS\", \"A*\"];\r\n    const mazeAlgos = [\r\n      \"Recursive BackTracking\",\r\n      \"Kruskal's Algorithm\",\r\n      \"Wilson's Random Walk\",\r\n      \"Prim's Algorithm\"\r\n    ];\r\n    return (\r\n      <div className=\"bar\">\r\n        <div className=\"searchBar\">\r\n          <h3 className=\"searchLabel\">SEARCH ALGO:</h3>\r\n          <Dropdown\r\n            className=\"dd\"\r\n            id=\"algoSelect\"\r\n            options={algos}\r\n            onChange={this.props.updateAlgo}\r\n            value={this.props.algoName}\r\n          ></Dropdown>\r\n\r\n          <button className=\"run_button\" onClick={this.props.algo}>\r\n            SEARCH\r\n          </button>\r\n          <button\r\n            className=\"clear_button\"\r\n            onClick={() => this.props.clear(true)}\r\n          >\r\n            CLEAR\r\n          </button>\r\n        </div>\r\n        <div className=\"mazeBar\">\r\n          <h3 className=\"mazeLabel\">MAZE ALGO:</h3>\r\n          <Dropdown\r\n            className=\"dd\"\r\n            id=\"mazeSelect\"\r\n            options={mazeAlgos}\r\n            onChange={this.props.updateMazeAlgo}\r\n            value={this.props.mazeAlgoName}\r\n          ></Dropdown>\r\n          <button className=\"maze_button\" onClick={this.props.mazeAlgo}>\r\n            GENERATE MAZE\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","export function BackTrack(grid, start, end) {\r\n  //   console.log(start);\r\n  //   console.log(end);\r\n  //console.log(grid);\r\n  for (const row in grid) {\r\n    for (const ind in grid[row]) {\r\n      grid[row][ind].visited = false;\r\n    }\r\n  }\r\n  const stack = [];\r\n  const path = [];\r\n  let current = start;\r\n  stack.push(start);\r\n  while (stack.length !== 0) {\r\n    //console.log(\"loop\");\r\n    current.visited = true;\r\n    const neighbs = GetUnvisitedNeighbours(current, grid);\r\n    const nextNode = GetPossibleNode(grid, neighbs);\r\n    if (nextNode != null) {\r\n      path.push(nextNode);\r\n      stack.push(nextNode);\r\n      current = nextNode;\r\n      // console.log(\"pushing\");\r\n    } else {\r\n      current = stack.pop();\r\n      //console.log(\"poping\");\r\n    }\r\n  }\r\n  //console.log(path);\r\n\r\n  const walls = [];\r\n  for (const row in grid) {\r\n    for (const ind in grid[row]) {\r\n      if (!path.includes(grid[row][ind]) && grid[row][ind] !== end) {\r\n        walls.push(grid[row][ind]);\r\n      }\r\n    }\r\n  }\r\n  console.log(walls);\r\n  return walls;\r\n}\r\nfunction GetPossibleNode(grid, neighbs) {\r\n  const nodeList = [];\r\n  for (const n in neighbs) {\r\n    if (GetUnvisitedNeighbours(neighbs[n], grid).length > 2) {\r\n      nodeList.push(neighbs[n]);\r\n    }\r\n  }\r\n  return nodeList[Math.floor(Math.random() * nodeList.length)];\r\n}\r\n\r\nfunction GetUnvisitedNeighbours(node, grid) {\r\n  //console.log(node);\r\n  const neighbs = [];\r\n  const row = node.row;\r\n  const col = node.col;\r\n  if (row !== 0) {\r\n    if (\r\n      grid[row - 1][col].visited === false &&\r\n      grid[row - 1][col].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row - 1][col]);\r\n    }\r\n    //console.log(grid[row - 1][col].visited === false);\r\n  }\r\n  if (col !== 0) {\r\n    if (\r\n      grid[row][col - 1].visited === false &&\r\n      grid[row][col - 1].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row][col - 1]);\r\n    }\r\n  }\r\n  if (row !== 20) {\r\n    if (\r\n      grid[row + 1][col].visited === false &&\r\n      grid[row + 1][col].isWall === false\r\n    ) {\r\n      //console.log(\"adding neighbours\");\r\n      neighbs.push(grid[row + 1][col]);\r\n    }\r\n  }\r\n  if (col !== 40) {\r\n    if (\r\n      grid[row][col + 1].visited === false &&\r\n      grid[row][col + 1].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row][col + 1]);\r\n    }\r\n  }\r\n\r\n  return neighbs;\r\n}\r\n","export function Kruskal(_grid, start, end) {\r\n  const grid = _grid.slice();\r\n  let walls = [];\r\n  // console.log(walls.length);\r\n  let sets = [];\r\n\r\n  let max_iter = 0;\r\n  InitializeGrid(grid, start, end, sets, walls);\r\n\r\n  while (sets.length > 1 && max_iter < 1000) {\r\n    let index = Math.floor(Math.random() * walls.length);\r\n\r\n    const wall = walls[index];\r\n\r\n    if (ValidHorizontalWall(walls, index)) {\r\n      const set1 = findContainingSet(sets, grid[wall.row][wall.col - 1]);\r\n      const set2 = findContainingSet(sets, grid[wall.row][wall.col + 1]);\r\n\r\n      if (set1 !== set2 && set1 !== -1 && set2 !== -1) {\r\n        walls.splice(index, 1);\r\n        for (let elem of sets[set1]) {\r\n          sets[set2].add(elem);\r\n        }\r\n        sets.splice(set1, 1);\r\n      }\r\n    } else if (ValidVerticalWall(walls, index)) {\r\n      const set1 = findContainingSet(sets, grid[wall.row - 1][wall.col]);\r\n      const set2 = findContainingSet(sets, grid[wall.row + 1][wall.col]);\r\n\r\n      if (set1 !== set2 && set1 !== -1 && set2 !== -1) {\r\n        walls.splice(index, 1);\r\n\r\n        for (let elem of sets[set1]) {\r\n          sets[set2].add(elem);\r\n        }\r\n        sets.splice(set1, 1);\r\n      }\r\n    }\r\n    max_iter++;\r\n    //console.log(sets.length);\r\n  }\r\n\r\n  return walls;\r\n}\r\nfunction ValidHorizontalWall(walls, index) {\r\n  return (\r\n    walls[index].col % 2 === 0 &&\r\n    walls[index].col !== 0 &&\r\n    walls[index].col !== 40\r\n  );\r\n}\r\nfunction ValidVerticalWall(walls, index) {\r\n  return (\r\n    walls[index].row % 2 === 0 &&\r\n    walls[index].row !== 0 &&\r\n    walls[index].row !== 20\r\n  );\r\n}\r\n\r\nfunction InitializeGrid(grid, start, end, sets, walls) {\r\n  for (const row in grid) {\r\n    for (const col in grid[row]) {\r\n      if (\r\n        (row % 2 === 1 && col % 2 === 1) ||\r\n        grid[row][col] === start ||\r\n        grid[row][col] === end\r\n      ) {\r\n        const set = new Set();\r\n        set.add(grid[row][col]);\r\n        sets.push(set);\r\n      } else {\r\n        walls.push(grid[row][col]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction findContainingSet(sets, elem) {\r\n  //   console.log(elem);\r\n  //   console.log(sets);\r\n\r\n  for (const set in sets) {\r\n    //console.log(sets[set]);\r\n    if (sets[set].has(elem)) {\r\n      return set;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n","export function Prims(_grid, start, end) {\r\n  const grid = _grid.slice();\r\n  let walls = [];\r\n  // console.log(walls.length);\r\n  let sets = [];\r\n\r\n  let max_iter = 0;\r\n  InitializeGrid(grid, start, end, sets, walls);\r\n\r\n  while (sets.length > 1 && max_iter < 1000) {\r\n    let index = Math.floor(Math.random() * walls.length);\r\n\r\n    const wall = walls[index];\r\n\r\n    if (ValidHorizontalWall(walls, index)) {\r\n      const set1 = findContainingSet(sets, grid[wall.row][wall.col - 1]);\r\n      const set2 = findContainingSet(sets, grid[wall.row][wall.col + 1]);\r\n\r\n      if (set1 !== set2 && set1 !== -1 && set2 !== -1) {\r\n        walls.splice(index, 1);\r\n        for (let elem of sets[set1]) {\r\n          sets[set2].add(elem);\r\n        }\r\n        sets.splice(set1, 1);\r\n      }\r\n    } else if (ValidVerticalWall(walls, index)) {\r\n      const set1 = findContainingSet(sets, grid[wall.row - 1][wall.col]);\r\n      const set2 = findContainingSet(sets, grid[wall.row + 1][wall.col]);\r\n\r\n      if (set1 !== set2 && set1 !== -1 && set2 !== -1) {\r\n        walls.splice(index, 1);\r\n\r\n        for (let elem of sets[set1]) {\r\n          sets[set2].add(elem);\r\n        }\r\n        sets.splice(set1, 1);\r\n      }\r\n    }\r\n    max_iter++;\r\n    //console.log(sets.length);\r\n  }\r\n\r\n  return walls;\r\n}\r\nfunction ValidHorizontalWall(walls, index) {\r\n  return (\r\n    walls[index].col % 2 === 0 &&\r\n    walls[index].col !== 0 &&\r\n    walls[index].col !== 40\r\n  );\r\n}\r\nfunction ValidVerticalWall(walls, index) {\r\n  return (\r\n    walls[index].row % 2 === 0 &&\r\n    walls[index].row !== 0 &&\r\n    walls[index].row !== 20\r\n  );\r\n}\r\n\r\nfunction InitializeGrid(grid, start, end, sets, walls) {\r\n  for (const row in grid) {\r\n    for (const col in grid[row]) {\r\n      if (\r\n        (row % 2 === 1 && col % 2 === 1) ||\r\n        grid[row][col] === start ||\r\n        grid[row][col] === end\r\n      ) {\r\n        const set = new Set();\r\n        set.add(grid[row][col]);\r\n        sets.push(set);\r\n      } else {\r\n        walls.push(grid[row][col]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction findContainingSet(sets, elem) {\r\n  //   console.log(elem);\r\n  //   console.log(sets);\r\n\r\n  for (const set in sets) {\r\n    //console.log(sets[set]);\r\n    if (sets[set].has(elem)) {\r\n      return set;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n","export function Wilson(grid, start, end) {\r\n  //   console.log(start);\r\n  //   console.log(end);\r\n  //console.log(grid);\r\n  for (const row in grid) {\r\n    for (const ind in grid[row]) {\r\n      grid[row][ind].visited = false;\r\n    }\r\n  }\r\n  const stack = [];\r\n  const path = [];\r\n  let current = start;\r\n  stack.push(start);\r\n  while (stack.length !== 0) {\r\n    //console.log(\"loop\");\r\n    current.visited = true;\r\n    const neighbs = GetUnvisitedNeighbours(current, grid);\r\n    const nextNode = GetPossibleNode(grid, neighbs);\r\n    if (nextNode != null) {\r\n      path.push(nextNode);\r\n      stack.push(nextNode);\r\n      current = nextNode;\r\n      //   console.log(\"exploring\");\r\n    } else {\r\n      const index = Math.floor(Math.random() * stack.length);\r\n      current = stack.splice(index, 1)[0];\r\n      //   console.log(current);\r\n      //   console.log(\"chose new random node\");\r\n    }\r\n  }\r\n  //console.log(path);\r\n\r\n  const walls = [];\r\n  for (const row in grid) {\r\n    for (const ind in grid[row]) {\r\n      if (!path.includes(grid[row][ind]) && grid[row][ind] !== end) {\r\n        walls.push(grid[row][ind]);\r\n      }\r\n    }\r\n  }\r\n  console.log(walls);\r\n  return walls;\r\n}\r\nfunction GetPossibleNode(grid, neighbs) {\r\n  const nodeList = [];\r\n  for (const n in neighbs) {\r\n    if (GetUnvisitedNeighbours(neighbs[n], grid).length > 2) {\r\n      nodeList.push(neighbs[n]);\r\n    }\r\n  }\r\n  return nodeList[Math.floor(Math.random() * nodeList.length)];\r\n}\r\n\r\nfunction GetUnvisitedNeighbours(node, grid) {\r\n  //console.log(node);\r\n  const neighbs = [];\r\n  const row = node.row;\r\n  const col = node.col;\r\n  if (row !== 0) {\r\n    if (\r\n      grid[row - 1][col].visited === false &&\r\n      grid[row - 1][col].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row - 1][col]);\r\n    }\r\n    //console.log(grid[row - 1][col].visited === false);\r\n  }\r\n  if (col !== 0) {\r\n    if (\r\n      grid[row][col - 1].visited === false &&\r\n      grid[row][col - 1].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row][col - 1]);\r\n    }\r\n  }\r\n  if (row !== 20) {\r\n    if (\r\n      grid[row + 1][col].visited === false &&\r\n      grid[row + 1][col].isWall === false\r\n    ) {\r\n      //console.log(\"adding neighbours\");\r\n      neighbs.push(grid[row + 1][col]);\r\n    }\r\n  }\r\n  if (col !== 40) {\r\n    if (\r\n      grid[row][col + 1].visited === false &&\r\n      grid[row][col + 1].isWall === false\r\n    ) {\r\n      neighbs.push(grid[row][col + 1]);\r\n    }\r\n  }\r\n\r\n  return neighbs;\r\n}\r\nfunction compareNodes(node1, node2) {\r\n  if (node1.seen && !node2.seen) return -1;\r\n  if (!node1.seen && node2.seen) return 1;\r\n\r\n  return 0;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Square from \"./Square.jsx\";\r\nimport \"./Grid.css\";\r\nimport { BFS } from \"./search_algos/BFS.js\";\r\nimport { DFS } from \"./search_algos/DFS.js\";\r\nimport { Astar } from \"./search_algos/Astar.js\";\r\nimport SearchSelectionbar from \"./SelectionBar.jsx\";\r\nimport { BackTrack } from \"./maze_algos/backtracker.js\";\r\nimport { Kruskal } from \"./maze_algos/kruskal.js\";\r\nimport { Prims } from \"./maze_algos/prims.js\";\r\nimport { Wilson } from \"./maze_algos/wilson.js\";\r\nexport default class CenterGrid extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      algo: () => BFS(this.state.grid, this.state.start, this.state.end),\r\n      mazeAlgo: () =>\r\n        BackTrack(this.state.grid, this.state.start, this.state.end),\r\n      mazeAlgoName: \"Recursive BackTracking\",\r\n      algoName: \"BFS\",\r\n      isFresh: true,\r\n      mouseDown: false,\r\n      startSelected: false,\r\n      endSelected: false\r\n    };\r\n    this.toggleWall = this.toggleWall.bind(this);\r\n    this.refreshAndAnimate = this.refreshAndAnimate.bind(this);\r\n    this.refreshAndAnimateMaze = this.refreshAndAnimateMaze.bind(this);\r\n    this.updateAlgo = this.updateAlgo.bind(this);\r\n    this.updateMazeAlgo = this.updateMazeAlgo.bind(this);\r\n    this.clear = this.clear.bind(this);\r\n    this.selectStart = this.selectStart.bind(this);\r\n    this.moveStart = this.moveStart.bind(this);\r\n    this.selectEnd = this.selectEnd.bind(this);\r\n    this.moveEnd = this.moveEnd.bind(this);\r\n  }\r\n  componentDidMount() {\r\n    const { grid, start, end } = InitializeGrid();\r\n    // console.log(grid);\r\n    this.setState({ grid, start, end });\r\n  }\r\n  toggleWall(row, col) {\r\n    //console.log(this.state);\r\n    const tempGrid = this.state.grid.slice();\r\n\r\n    tempGrid[row][col].isWall =\r\n      tempGrid[row][col].isWall === true ? false : true;\r\n    this.setState({ grid: tempGrid, algo: this.state.algo });\r\n  }\r\n  createWalls(walls) {\r\n    const tempGrid = this.state.grid.slice();\r\n    for (const wall in walls) {\r\n      const row = walls[wall].row;\r\n      const col = walls[wall].col;\r\n      tempGrid[row][col].isWall = true;\r\n    }\r\n    this.setState({ grid: tempGrid });\r\n  }\r\n\r\n  updateAlgo(algo) {\r\n    // // console.log(\"TESTTTTTt\");\r\n    // console.log(algo);\r\n    // console.log(algo === \"BFS\");\r\n    if (algo.value === \"BFS\") {\r\n      console.log(\"in BFS\");\r\n      this.setState({\r\n        algoName: algo,\r\n        algo: () => BFS(this.state.grid, this.state.start, this.state.end)\r\n      });\r\n    }\r\n    if (algo.value === \"DFS\") {\r\n      console.log(\"in DFS\");\r\n      this.setState({\r\n        algoName: algo,\r\n        algo: () => DFS(this.state.grid, this.state.start, this.state.end)\r\n      });\r\n    }\r\n    if (algo.value === \"A*\") {\r\n      console.log(\"in A*\");\r\n      this.setState({\r\n        algoName: algo,\r\n        algo: () => Astar(this.state.grid, this.state.start, this.state.end)\r\n      });\r\n    }\r\n  }\r\n  updateMazeAlgo(algo) {\r\n    // // console.log(\"TESTTTTTt\");\r\n    // console.log(algo);\r\n    // console.log(algo === \"BFS\");\r\n    if (algo.value === \"Recursive BackTracking\") {\r\n      console.log(\"in Recursive BackTracking\");\r\n      this.setState({\r\n        mazeAlgoName: algo,\r\n        mazeAlgo: () =>\r\n          BackTrack(this.state.grid, this.state.start, this.state.end)\r\n      });\r\n    }\r\n    if (algo.value === \"Kruskal's Algorithm\") {\r\n      console.log(\"in Kruskal\");\r\n      this.setState({\r\n        mazeAlgoName: algo,\r\n        mazeAlgo: () =>\r\n          Kruskal(this.state.grid, this.state.start, this.state.end)\r\n      });\r\n    }\r\n    if (algo.value === \"Prim's Algorithm\") {\r\n      console.log(\"in Prims\");\r\n      this.setState({\r\n        mazeAlgoName: algo,\r\n        mazeAlgo: () => Prims(this.state.grid, this.state.start, this.state.end)\r\n      });\r\n    }\r\n    if (algo.value === \"Wilson's Random Walk\") {\r\n      console.log(\"in Wilson\");\r\n      this.setState({\r\n        mazeAlgoName: algo,\r\n        mazeAlgo: () =>\r\n          Wilson(this.state.grid, this.state.start, this.state.end)\r\n      });\r\n    }\r\n  }\r\n\r\n  animateSearchAlgo(algo) {\r\n    this.setState({ isFresh: false });\r\n    const orderedSquares = algo.vstd;\r\n    const shortestPath = algo.shortestPath;\r\n    //console.log(orderedSquares);\r\n    //console.log(shortestPath);\r\n    for (const index in orderedSquares) {\r\n      setTimeout(() => {\r\n        for (const pathIndex in shortestPath) {\r\n          setTimeout(() => {\r\n            const square = shortestPath[pathIndex];\r\n            if (\r\n              document.getElementById(`square-${square.row}-${square.col}`)\r\n                .className !== \"square  start\" &&\r\n              document.getElementById(`square-${square.row}-${square.col}`)\r\n                .className !== \"square  end\"\r\n            ) {\r\n              document.getElementById(\r\n                `square-${square.row}-${square.col}`\r\n              ).className = \"square shortest\";\r\n            }\r\n          }, 3 * orderedSquares.length + 25 * pathIndex);\r\n        }\r\n        const square = orderedSquares[index];\r\n        if (\r\n          document.getElementById(`square-${square.row}-${square.col}`)\r\n            .className === \"square  \"\r\n        ) {\r\n          document.getElementById(\r\n            `square-${square.row}-${square.col}`\r\n          ).className += \" visited\";\r\n        }\r\n      }, 3 * index);\r\n    }\r\n  }\r\n\r\n  clear(resetWalls) {\r\n    const { grid, start, end } = RefreshGrid(\r\n      this.state.grid.slice(),\r\n      resetWalls,\r\n      this.state.start,\r\n      this.state.end\r\n    );\r\n    // console.log(grid);\r\n    this.setState({ grid, start, end, isFresh: true });\r\n    for (let row in this.state.grid) {\r\n      for (let ind in this.state.grid[row]) {\r\n        //console.log(ind);\r\n        const square = this.state.grid[row][ind];\r\n        //console.log(square);\r\n        if (resetWalls) {\r\n          if (\r\n            document.getElementById(`square-${square.row}-${square.col}`)\r\n              .className !== \"square  start\" &&\r\n            document.getElementById(`square-${square.row}-${square.col}`)\r\n              .className !== \"square  end\"\r\n          )\r\n            document.getElementById(\r\n              `square-${square.row}-${square.col}`\r\n            ).className = \"square  \";\r\n        } else if (\r\n          document.getElementById(`square-${square.row}-${square.col}`)\r\n            .className !== \"square  wall\" &&\r\n          document.getElementById(`square-${square.row}-${square.col}`)\r\n            .className !== \"square  start\" &&\r\n          document.getElementById(`square-${square.row}-${square.col}`)\r\n            .className !== \"square  end\"\r\n        )\r\n          document.getElementById(\r\n            `square-${square.row}-${square.col}`\r\n          ).className = \"square  \";\r\n      }\r\n    }\r\n    //console.log(grid);\r\n  }\r\n  moveStart(row, col) {\r\n    const newStart = { row, col };\r\n    const { grid, start, end } = RefreshGrid(\r\n      this.state.grid.slice(),\r\n      false,\r\n      newStart,\r\n      this.state.end\r\n    );\r\n    this.setState({ grid, start, end }, console.log(this.state.start));\r\n  }\r\n  selectStart() {\r\n    this.setState({ startSelected: true }, () => console.log(\"start selected\"));\r\n  }\r\n  moveEnd(row, col) {\r\n    const newEnd = { row, col };\r\n    const { grid, start, end } = RefreshGrid(\r\n      this.state.grid.slice(),\r\n      false,\r\n      this.state.start,\r\n      newEnd\r\n    );\r\n    this.setState({ grid, start, end }, console.log(this.state.end));\r\n  }\r\n  selectEnd() {\r\n    this.setState({ endSelected: true }, () => console.log(\"end selected\"));\r\n  }\r\n  mouseDown() {\r\n    this.setState({ mouseDown: true }, () => console.log(this.state.mouseDown));\r\n  }\r\n  mouseUp() {\r\n    this.setState({ mouseDown: false }, () =>\r\n      console.log(this.state.mouseDown)\r\n    );\r\n    this.setState({ startSelected: false }, () =>\r\n      console.log(this.state.startSelected)\r\n    );\r\n    this.setState({ endSelected: false }, () =>\r\n      console.log(this.state.endSelected)\r\n    );\r\n  }\r\n  refreshAndAnimate() {\r\n    if (this.state.isFresh === false) {\r\n      this.clear(false);\r\n    }\r\n    //console.log(this.state.grid[0]);\r\n    this.animateSearchAlgo(this.state.algo());\r\n  }\r\n  refreshAndAnimateMaze() {\r\n    this.clear(true);\r\n    setTimeout(() => this.animateMazeAlgo(this.state.mazeAlgo()), 50);\r\n\r\n    this.setState({ isFresh: false });\r\n  }\r\n  animateMazeAlgo(walls) {\r\n    this.createWalls(walls);\r\n    this.forceUpdate();\r\n  }\r\n  render() {\r\n    const { grid } = this.state;\r\n    return (\r\n      <div\r\n        className=\"grid\"\r\n        onMouseDown={() => this.mouseDown()}\r\n        onMouseUp={() => this.mouseUp()}\r\n      >\r\n        <SearchSelectionbar\r\n          algo={this.refreshAndAnimate}\r\n          mazeAlgo={this.refreshAndAnimateMaze}\r\n          mazeAlgoName={this.state.mazeAlgoName}\r\n          algoName={this.state.algoName}\r\n          updateAlgo={this.updateAlgo}\r\n          updateMazeAlgo={this.updateMazeAlgo}\r\n          clear={this.clear}\r\n        />\r\n        <div className=\"gridBox\">\r\n          {grid.map((row, rIndex) => {\r\n            return (\r\n              <div className=\"row\" key={rIndex}>\r\n                {row.map((square, cIndex) => {\r\n                  // console.log(square.isStart);\r\n\r\n                  return (\r\n                    <Square\r\n                      key={cIndex}\r\n                      row={rIndex}\r\n                      col={cIndex}\r\n                      isStart={square.isStart}\r\n                      isEnd={square.isEnd}\r\n                      isWall={this.state.grid[square.row][square.col].isWall}\r\n                      toggleWall={this.toggleWall}\r\n                      mouseDown={this.state.mouseDown}\r\n                      selectStart={this.selectStart}\r\n                      startSelected={this.state.startSelected}\r\n                      moveStart={this.moveStart}\r\n                      selectEnd={this.selectEnd}\r\n                      endSelected={this.state.endSelected}\r\n                      moveEnd={this.moveEnd}\r\n                    />\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst InitializeGrid = () => {\r\n  const grid = [];\r\n  let start = null;\r\n  let end = null;\r\n  for (let row = 0; row < 21; row++) {\r\n    const tempRow = [];\r\n    for (let col = 0; col < 41; col++) {\r\n      const isStart = row === 5 && col === 5;\r\n      const isEnd = row === 18 && col === 33;\r\n      const square = {\r\n        row,\r\n        col,\r\n        isStart,\r\n        isEnd,\r\n        visited: false,\r\n        isWall: false\r\n      };\r\n\r\n      if (square.isStart) {\r\n        start = square;\r\n      }\r\n\r\n      if (square.isEnd) {\r\n        end = square;\r\n      }\r\n      tempRow.push(square);\r\n    }\r\n    grid.push(tempRow);\r\n  }\r\n  //console.log(grid);\r\n  return { grid, start, end };\r\n};\r\nconst RefreshGrid = (gridOrig, resetWalls, start, end) => {\r\n  const grid = [];\r\n\r\n  for (let row = 0; row < 21; row++) {\r\n    const tempRow = [];\r\n    for (let col = 0; col < 41; col++) {\r\n      const isStart = row === start.row && col === start.col;\r\n      const isEnd = row === end.row && col === end.col;\r\n      const square = {\r\n        row,\r\n        col,\r\n        isStart,\r\n        isEnd,\r\n        visited: false,\r\n        isWall: resetWalls ? false : gridOrig[row][col].isWall\r\n      };\r\n      //console.log(square.isWall);\r\n\r\n      if (square.isStart) {\r\n        start = square;\r\n      }\r\n\r\n      if (square.isEnd) {\r\n        end = square;\r\n      }\r\n      tempRow.push(square);\r\n    }\r\n    grid.push(tempRow);\r\n  }\r\n  //console.log(grid);\r\n  return { grid, start, end };\r\n};\r\n","import React, { Component } from \"react\";\r\nimport Grid from \"./Grid.jsx\";\r\nimport \"./Display.css\";\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faCubes } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nexport default class Display extends Component {\r\n  render() {\r\n    return (\r\n      <div className=\"container\">\r\n        <div className=\"topbar\">\r\n          <div className=\"icon\">\r\n            <FontAwesomeIcon icon={faCubes} />\r\n          </div>\r\n          <h1 className=\"ad\">ALGO DISPLAY</h1>\r\n        </div>\r\n        <Grid />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\nimport logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Display from \"./Display.jsx\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Display />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}